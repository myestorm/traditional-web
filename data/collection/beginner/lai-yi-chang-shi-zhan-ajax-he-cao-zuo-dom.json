{"body":"<h1 id=\"%E6%9D%A5%E4%B8%80%E5%9C%BA%E5%AE%9E%E6%88%98%EF%BC%8Cajax%E5%92%8C%E6%93%8D%E4%BD%9Cdom\"><a class=\"header-anchor\" href=\"#%E6%9D%A5%E4%B8%80%E5%9C%BA%E5%AE%9E%E6%88%98%EF%BC%8Cajax%E5%92%8C%E6%93%8D%E4%BD%9Cdom\">¶</a> 来一场实战，ajax和操作dom</h1>\n<h2 id=\"%E4%BB%80%E4%B9%88%E6%98%AFajax\"><a class=\"header-anchor\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFajax\">¶</a> 什么是ajax</h2>\n<blockquote>\n<p>Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术。\n通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>\n</blockquote>\n<p>我的理解比较直接一些，就是向服务端发送数据或者从服务端获取数据。</p>\n<h2 id=\"ajax%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B%E4%B8%8Erestful-api\"><a class=\"header-anchor\" href=\"#ajax%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B%E4%B8%8Erestful-api\">¶</a> ajax请求类型与RESTful API</h2>\n<p>ajax请求类型一般分为4类， <code>POST</code> <code>GET</code> <code>PUT</code> <code>DELETE</code> 。一般使用post和get。\n当前后端完全分离以后，服务端只提供ajax接口，一般操作类型就是增改查删（CURD）\n假设我们数据库里有一张User表，我们根据表对象模型User，按照restful规范设计的接口应该是这样的：\n新增用户:[POST] /users\n修改用户:[PUT] /users/id\n删除用户:[DELETE] /users/id\n查找全部用户:[GET] /users\n这样ajax的请求类型就和接口的类型对应起来了，而且非常清晰。</p>\n<p>当然不一定非要这么用，只是说这么用比较合适。</p>\n<h2 id=\"%E5%8F%91%E9%80%81ajax%E8%AF%B7%E6%B1%82%E7%9A%84%E6%96%B9%E5%BC%8F\"><a class=\"header-anchor\" href=\"#%E5%8F%91%E9%80%81ajax%E8%AF%B7%E6%B1%82%E7%9A%84%E6%96%B9%E5%BC%8F\">¶</a> 发送ajax请求的方式</h2>\n<ol>\n<li>axios 【插件】</li>\n<li>jQuery的ajax 【插件】</li>\n<li>ES6中的 fetch</li>\n<li>XMLHttpRequest对象</li>\n</ol>\n<p>上面的两个插件非常好用，一般情况下我们无需用原生的js去实现，使用插件更加方便。用原生的js来写demo只是为了更好的理解过程。</p>\n<h2 id=\"%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8Bpromise\"><a class=\"header-anchor\" href=\"#%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8Bpromise\">¶</a> 了解一下Promise</h2>\n<p>在这个教程里面只说基础的用法，更深入的部分自行学习。ajax是一个典型的异步请求，啥叫异步呢？一般来说代码是一行一行执行，理论上来说是执行完第一行再执行第二行，这个就叫“同步”；如果第一行是异步的话，就是说在执行第二步的时候，第一步并没有执行完成。为了在第二步中能使用第一步中的结果，最早的方式是使用回调，就是把第二步当成一个函数，传给第一步，等第一步执行完成在执行这个函数。如果异步的过程很多的时候，就歇菜了，代码基本很很难阅读和理解，这个就是所谓的“回调地狱”。所以Promise能比较优雅的解决这个问题。</p>\n<pre><code class=\"language-javascript\">// 用回调的方式\nfunction read (cb) {\n  let a = 1\n  setTimeout(() =&gt; { // 2秒后完成操作\n    a = 30\n    if (cb) {\n      cb(a)\n    }\n  }, 2000)\n}\nread((num) =&gt; {\n  console.log(num)\n})\n\n// 用promise的方式\nfunction readPromise () {\n  let a = 1\n  return new Promise((resolve) =&gt; {\n    setTimeout(() =&gt; { // 2秒后完成操作\n      a = 30\n      resolve(a)\n    }, 2000)\n  })\n}\nreadPromise().then(num =&gt; {\n  console.log(num)\n})\n</code></pre>\n<p>附加说一下，高频面试题：\nPromise.all() 可以用来一次执行多个异步任务\nPromise.race() 获得先返回的结果</p>\n<h2 id=\"%E5%8E%9F%E7%94%9F%E7%9A%84js%E6%9D%A5%E5%86%99%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%9A%84%E8%8C%83%E4%BE%8B\"><a class=\"header-anchor\" href=\"#%E5%8E%9F%E7%94%9F%E7%9A%84js%E6%9D%A5%E5%86%99%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%9A%84%E8%8C%83%E4%BE%8B\">¶</a> 原生的JS来写一个请求的范例</h2>\n<p>来一个to do list</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;to do list&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div&gt;\n      &lt;ul id=&quot;to-do-list&quot;&gt;&lt;/ul&gt;\n      &lt;button id=&quot;add&quot;&gt;添加&lt;/button&gt;\n    &lt;/div&gt;\n    &lt;script&gt;\n      const id = 'to-do-list'\n      const container = document.querySelector(`#${id}`)\n      const btn = document.querySelector('#add')\n      // ajax请求方法\n      const ajax = (method = 'GET', url, data = {}) =&gt; {\n        return new Promise((resolve, reject) =&gt; {\n          const xhr = new XMLHttpRequest()\n          // 请求成功回调函数\n          xhr.onload = e =&gt; {\n            resolve(JSON.parse(xhr.response)) // 将服务端返回的数据返回\n          }\n          // 请求出错\n          xhr.onerror = e =&gt; {\n            // 返回错误\n            reject({\n              code: -1,\n              msg: '请求出错'\n            })\n          }\n          // 请求超时\n          xhr.ontimeout = e =&gt; {\n            // 返回错误\n            reject({\n              code: -2,\n              msg: '请求超时'\n            })\n          }\n          xhr.open(method, url, true);\n          xhr.send(data)\n        })\n      }\n      // 获取列表\n      ajax('GET', 'http://yapi.totonoo.com/mock/11/list').then(res =&gt; {\n        // 这里是成功后执行的操作\n        let html = ''\n        res.data.forEach(item =&gt; {\n          // 拼接字符串\n          html += `&lt;li&gt;&lt;label&gt;&lt;input type=&quot;checkbox&quot;&gt; ${item.title}&lt;/label&gt;&lt;/li&gt;`\n        })\n        // 将拼接好的字符串插入到指定的位置\n        container.innerHTML = html\n      }).catch(err =&gt; {\n        // 这里是失败后执行的操作\n        alert(err.msg)\n      }).finally(() =&gt; {\n        // 完成后执行，不管成功或者失败，只要这一次请求完成了\n          console.log('done)\n      })\n      // 添加事件\n      btn.addEventListener('click', () =&gt; {\n        // 表单参数\n        const formData = new FormData()\n        formData.append('username', 'lurenjia');\n        ajax('POST', 'http://yapi.totonoo.com/mock/11/add', formData).then(res =&gt; {\n          // 创建DOM\n          const item = document.createElement('li')\n          // 插入内容\n          item.innerHTML = '&lt;label&gt;&lt;input type=&quot;checkbox&quot;&gt; 新增的&lt;/label&gt;'\n          // 在指定位置的最后插入创建的dom\n          container.appendChild(item)\n        }).catch(err =&gt; {\n          alert(err.msg)\n        })\n      })\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>PUT、DELETE跟上面的类似，可以自己尝试去弄一下，这里就到此为止。</p>\n<h2 id=\"http%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3\"><a class=\"header-anchor\" href=\"#http%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3\">¶</a> http请求的过程详解</h2>\n<p>这个实际上就是描述，从用户从浏览器敲入网址之后回车，到浏览器显示页面的过程。\n<img src=\"10/1.jpeg\" alt=\"1.jpg\"></p>\n<h2 id=\"%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98\"><a class=\"header-anchor\" href=\"#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98\">¶</a> 如何解决跨域问题</h2>\n<p>为什么会有跨域的问题？浏览器为了安全，使用同源策略导致了跨域。如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指&quot;协议+域名+端口&quot;三者相同，即便两个不同的域名指向同一个ip地址，也非同源。\n同源策略限制的表现（网上复制的）</p>\n<blockquote>\n<ol>\n<li>Cookie、LocalStorage 和 IndexDB 无法读取</li>\n<li>DOM 和 Js对象无法获得</li>\n<li>AJAX 请求不能发送</li>\n</ol>\n</blockquote>\n<p>一般来说前端最常见的表现就是AJAX 请求不能发送，1和2一般没有人在意，也不会有人这么做。</p>\n<p>常用解决跨域的方法：</p>\n<ol>\n<li>Nginx反向代理</li>\n<li>Node中间代理</li>\n<li>CORS</li>\n<li>document.domain + iframe</li>\n</ol>\n<p>推荐顺序从上到下，如果前端使用Node提供http服务，推荐使用第二种方式。3依赖于后端，4我基本已经不怎么用了。</p>\n","path":"collection/beginner","pathTitle":"初级教程","navigation":[{"tag":"h1","slug":"%E6%9D%A5%E4%B8%80%E5%9C%BA%E5%AE%9E%E6%88%98%EF%BC%8Cajax%E5%92%8C%E6%93%8D%E4%BD%9Cdom","title":"来一场实战，ajax和操作dom"},{"tag":"h2","slug":"%E4%BB%80%E4%B9%88%E6%98%AFajax","title":"什么是ajax"},{"tag":"h2","slug":"ajax%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B%E4%B8%8Erestful-api","title":"ajax请求类型与RESTful API"},{"tag":"h2","slug":"%E5%8F%91%E9%80%81ajax%E8%AF%B7%E6%B1%82%E7%9A%84%E6%96%B9%E5%BC%8F","title":"发送ajax请求的方式"},{"tag":"h2","slug":"%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8Bpromise","title":"了解一下Promise"},{"tag":"h2","slug":"%E5%8E%9F%E7%94%9F%E7%9A%84js%E6%9D%A5%E5%86%99%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%9A%84%E8%8C%83%E4%BE%8B","title":"原生的JS来写一个请求的范例"},{"tag":"h2","slug":"http%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3","title":"http请求的过程详解"},{"tag":"h2","slug":"%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98","title":"如何解决跨域问题"}],"orderIndex":10,"filename":"lai-yi-chang-shi-zhan-ajax-he-cao-zuo-dom"}